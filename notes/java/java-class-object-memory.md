# Java 클래스, 객체, 메모리 구조 핵심 정리

> 클래스, 객체(인스턴스), 메모리 구조, 생성자, 접근 제어자까지 **자바 객체지향의 기초 개념**을 한 번에 정리한 문서입니다.

---

## 1. 클래스와 멤버 변수

* **클래스(Class)** 는 객체를 만들기 위한 설계도이다.
* 클래스 내부에 선언하는 변수를 **멤버 변수(Member Variable)** 라고 한다.
* 멤버 변수는 다른 말로 **속성(Attribute)**, **특성(Property)** 이라고도 부른다.
* 멤버 변수는 표현하려는 속성에 맞는 **자료형**으로 선언해야 한다.

```java
class Student {
    String name;
    int age;
}
```

---

## 2. 멤버 함수(메서드)

* 클래스 내부에서 멤버 변수를 사용하여 기능을 구현한 함수를 **멤버 함수** 또는 **메서드(Method)** 라고 한다.
* 메서드는 객체가 할 수 있는 **동작(행위)** 을 의미한다.

예시:

* 학생에게 이름을 부여한다
* 학생이 사는 곳을 출력한다

```java
class Student {
    String name;
    String address;

    void setName(String n) {
        name = n;
    }

    void showAddress() {
        System.out.println(address);
    }
}
```

---

## 3. 패키지(Package)

* **패키지**는 클래스 파일들의 묶음이다.
* 패키지를 생성하면 프로젝트 하위에 **물리적인 디렉터리**가 생성된다.
* 패키지는 **계층 구조**를 가질 수 있다.

```text
com.example.school.student
```

---

## 4. 함수 호출과 스택(Stack) 메모리

* 함수가 호출되면 해당 함수만을 위한 메모리 공간이 생성된다.
* 이 메모리 공간을 **스택(Stack) 메모리**라고 한다.

### 실행 흐름 예시

1. 프로그램 시작 → `main()` 함수 호출
2. `main()` 함수의 지역 변수를 위한 스택 공간 생성
3. `main()`에서 `add()` 함수 호출
4. `add()` 함수용 스택 공간이 새로 생성
5. `add()` 함수 종료 → 해당 스택 공간 제거
6. `main()` 함수 종료 → 스택 공간 제거

* 함수 호출 순서가 **A → B → C** 라면
* 반환(종료) 순서는 **C → B → A**
* 스택 메모리는 **후입선출(LIFO)** 구조이다.

---

## 5. 지역 변수

* **지역 변수(Local Variable)** 는 스택 메모리에 생성된다.
* 함수가 종료되면 자동으로 소멸된다.

---

## 6. main 함수에서 클래스 사용하는 방법

클래스를 사용하는 방법은 두 가지가 있다.

1. **클래스 내부에 main() 함수 작성**
2. **외부에 테스트용 클래스를 만들어 사용**

```java
public class TestStudent {
    public static void main(String[] args) {
        Student s = new Student();
    }
}
```

---

## 7. 객체 생성과 new 예약어

```java
클래스형 변수이름 = new 생성자();
```

* `new` 예약어는 클래스의 **인스턴스(객체)** 를 생성한다.
* 객체가 생성되면 **힙(Heap) 메모리**에 메모리 공간이 할당된다.
* 이렇게 실제로 사용 가능한 상태가 된 클래스를 **인스턴스**라고 한다.
* 인스턴스를 가리키는 변수를 **참조 변수(Reference Variable)** 라고 한다.

```java
Student studentAhn = new Student();
```

---

## 8. 스택과 힙 메모리 관계

* `studentAhn` → 지역 변수 → **스택 메모리**
* `new Student()` → 인스턴스 → **힙 메모리**

즉,

* 참조 변수에는 **힙 메모리의 주소값**이 저장된다.
* 참조 변수에 인스턴스를 대입한다는 것은
  → 힙 메모리 주소를 대입하는 것과 같은 의미이다.

---

## 9. 인스턴스 변수

* 클래스의 멤버 변수는 인스턴스가 생성될 때마다 각각 따로 만들어진다.
* 따라서 멤버 변수는 **인스턴스 변수**라고도 부른다.

```java
Student s1 = new Student();
Student s2 = new Student();
```

* `s1`과 `s2`는 서로 다른 힙 메모리 공간을 참조한다.
* 멤버 변수 또한 각각 독립적인 공간을 가진다.

---

## 10. 객체 주소와 해시코드

* 힙 메모리에 생성된 인스턴스의 주소는 참조 변수에 저장된다.
* 객체를 출력하면 다음과 같은 형태로 보인다.

```text
클래스이름@해시코드값
```

* 이 주소값을 흔히 **해시코드(HashCode)** 값이라고 부른다.
* 참조 변수를 통해 해당 인스턴스를 참조할 수 있다.

---

## 11. 생성자(Constructor)

* **생성자**는 객체가 생성될 때 호출되는 특수한 메서드이다.

### 디폴트 생성자

* 생성자를 하나도 만들지 않으면
  → 컴파일러가 자동으로 **디폴트 생성자**를 제공한다.
* 매개변수가 없고 구현 코드도 없다.

```java
Student() {}
```

* 필요하다면 디폴트 생성자를 직접 구현할 수도 있다.

---

## 12. 생성자 오버로드

* 클래스에 **두 개 이상의 생성자**를 제공하는 것을
  **생성자 오버로드(Constructor Overload)** 라고 한다.

```java
Student() {}
Student(String name) {
    this.name = name;
}
```

* 매개변수가 다른 여러 생성자를 정의할 수 있다.
* 객체 생성 시 원하는 생성자를 선택해 사용할 수 있다.

---

## 13. 접근 제어자(Access Modifier)

접근 제어자는 클래스, 변수, 메서드의 접근 범위를 제한한다.

| 접근 제어자    | 접근 가능 범위           |
| --------- | ------------------ |
| public    | 모든 클래스에서 접근 가능     |
| protected | 같은 패키지 + 상속 관계 클래스 |
| default   | 같은 패키지 내부에서만 접근 가능 |
| private   | 같은 클래스 내부에서만 접근 가능 |

---

## 14. Getter / Setter

* 멤버 변수를 `private`으로 선언하면 외부 접근이 불가능하다.
* 이를 보완하기 위해 **public 메서드**를 제공한다.

```java
public class Student {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

* `get()` : 값 반환
* `set()` : 값 설정

---

## 📌 정리 한 줄 요약

> **클래스는 설계도, 객체는 실체, 스택은 호출 흐름, 힙은 객체 저장 공간이다.**
